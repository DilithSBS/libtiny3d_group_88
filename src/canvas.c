#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "../include/canvas.h"

canvas_t *canvas_create(size_t width, size_t height) {
    canvas_t *canvas = malloc(sizeof(canvas_t));

    if (!canvas) return NULL;

    // Sores height and width in the canvas structure
    canvas->width = width;
    canvas->height = height;

    // Allocates memory for a 1D array of row pointers
    canvas->pixels = malloc(height * sizeof(float*));
    if (!canvas->pixels) {
        free(canvas); 
        return NULL;
    }

    // Looping through each row of pixels and initializing them to zeros (black colour)
    for (size_t y = 0; y < height; y++) {
        canvas->pixels[y] = calloc(width, sizeof(float)); // initialized to 0.0
        if (!canvas->pixels[y]) {
            for (size_t j = 0; j < y; j++) free(canvas->pixels[j]);
            free(canvas->pixels);           // Free the memory used by canvas
            free(canvas);
            return NULL;
        }
    }

    return canvas;
}

void canvas_destroy(canvas_t* canvas) {

    if (!canvas) return;

    for (size_t y = 0; y < canvas->height; y++) {
        free(canvas->pixels[y]);        // Free each row of the canvas
    }
    // Free the array of row pointers and the canvas struct
    free(canvas->pixels);
    free(canvas);
}

void set_pixel_f(canvas_t* canvas, float x, float y, float intensity) {

    if (!canvas) return;

    // Find the top left integer pixel of the canvas
    int x0 = (int)floorf(x);
    int y0 = (int)floorf(y);
    
    // Calculate the distance to the point from (x0, y0)
    float dx = x - x0;
    float dy = y - y0;

    // Compute weights of the 4 surrounding pixels
    float w00 = (1 - dx) * (1 - dy);        // Top left
    float w10 = dx * (1 - dy);              // Top right
    float w01 = (1 - dx) * dy;              // Bottom left
    float w11 = dx * dy;                    // Bottom right

    // Apply brightness to each neighbor pixel if they are within canvas bounds
    if (x0 >= 0 && y0 >= 0 && x0 < (int)canvas->width && y0 < (int)canvas->height)
        canvas->pixels[y0][x0] += w00 * intensity;

    if (x0 + 1 >= 0 && y0 >= 0 && x0 + 1 < (int)canvas->width && y0 < (int)canvas->height)
        canvas->pixels[y0][x0 + 1] += w10 * intensity;

    if (x0 >= 0 && y0 + 1 >= 0 && x0 < (int)canvas->width && y0 + 1 < (int)canvas->height)
        canvas->pixels[y0 + 1][x0] += w01 * intensity;

    if (x0 + 1 >= 0 && y0 + 1 >= 0 && x0 + 1 < (int)canvas->width && y0 + 1 < (int)canvas->height)
        canvas->pixels[y0 + 1][x0 + 1] += w11 * intensity;
}

void draw_line_f(canvas_t* canvas, float x0, float y0, float x1, float y1, float thickness) {
    if (!canvas) return;

    float dx = x1 - x0;                         // X distance
    float dy = y1 - y0;                         // y distance
    float length = sqrtf(dx * dx + dy * dy);    // Length of the line

    if (length == 0.0f) return;                 // If length = 0 exit

    float unit_x = dx / length;                 // Unit x vector
    float unit_y = dy / length;                 // Unit y vector

    float tx = -unit_y;  // perpendicular unit vector x
    float ty = unit_x;   // perpendicular unit vector y

    for (float i = 0; i < length; i += 0.5f) {
        float x_pos = x0 + unit_x * i;      // x position
        float y_pos = y0 + unit_y * i;      // y position

        // draw thickness by drawing perpendicular mini-lines
        for (float t = -thickness / 2.0f; t <= thickness / 2.0f; t += 0.5f) {
            float fx = x_pos + tx * t;
            float fy = y_pos + ty * t;
            set_pixel_f(canvas, fx, fy, 1.0f);      // Set each pixel
        }
    }
}

void canvas_save_pgm(canvas_t *canvas, const char *filename) {
    FILE *f = fopen(filename, "w");
    if (!f) {
        perror("Failed to open file for writing");
        return;
    }

    fprintf(f, "P2\n");
    fprintf(f, "# Generated by libtiny3d\n");
    fprintf(f, "%lld %lld\n", canvas->width, canvas->height);
    fprintf(f, "255\n");

    for (int y = 0; y < canvas->height; y++) {
        for (int x = 0; x < canvas->width; x++) {
            float val = canvas->pixels[y][x];
            if (val > 1.0f) val = 1.0f;
            if (val < 0.0f) val = 0.0f;
            int gray = (int)(val * 255.0f);
            fprintf(f, "%d ", gray);
        }
        fprintf(f, "\n");
    }

    fclose(f);
}